(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{506:function(e,r,t){"use strict";t.r(r);var _=t(6),v=Object(_.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("从今天开始，打算每天一道面试题，慢慢积累的过程中希望学到些知识。今天先说一下重绘和回流。")]),e._v(" "),t("p",[e._v("这是页面优化中的一项内容。")]),e._v(" "),t("p",[e._v("首先，思考一个问题：")]),e._v(" "),t("h2",{attrs:{id:"html加载时发生了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#html加载时发生了什么"}},[e._v("#")]),e._v(" html加载时发生了什么？")]),e._v(" "),t("p",[e._v("在页面加载时，浏览器通过解析收到的html代码，构建一个个html元素，构建DOM。")]),e._v(" "),t("p",[e._v("浏览器把所有样式解析成样式结构体 .")]),e._v(" "),t("p",[e._v("DOM树和样式结构体组合后构建render树. render tree类似于DOM tree，但区别很大，因为render tree能识别样式，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。我自己简单的理解就是DOM Tree和我们写的CSS结合在一起之后，渲染出了render tree。")]),e._v(" "),t("h2",{attrs:{id:"什么是重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是重绘"}},[e._v("#")]),e._v(" 什么是重绘?")]),e._v(" "),t("p",[e._v("当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。")]),e._v(" "),t("h2",{attrs:{id:"什么是回流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是回流"}},[e._v("#")]),e._v(" 什么是回流?")]),e._v(" "),t("p",[e._v("当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。")]),e._v(" "),t("h2",{attrs:{id:"怎么减少回流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么减少回流"}},[e._v("#")]),e._v(" 怎么减少回流")]),e._v(" "),t("p",[e._v("说了这么多，我们也知道了，回流要重新构建DOM树，渲染树也得重新渲染，很麻烦，哪么哪些行为会引起回流，怎么去避免呢？")]),e._v(" "),t("p",[t("strong",[e._v("1.DOM的增删行为")])]),e._v(" "),t("p",[e._v("比如你要删除某个节点，给某个父元素增加子元素，这类操作都会引起回流。如果要加多个子元素，最好使用documentfragment。")]),e._v(" "),t("p",[t("strong",[e._v("2.几何属性的变化")])]),e._v(" "),t("p",[e._v("比如元素宽高变了，border变了，字体大小变了，这种直接会引起页面布局变化的操作也会引起回流。如果你要改变多个属性，最好将这些属性定义在一个class中，直接修改class名，这样只用引起一次回流。")]),e._v(" "),t("p",[t("strong",[e._v("3.元素位置的变化")])]),e._v(" "),t("p",[e._v("修改一个元素的左右margin，padding之类的操作，所以在做元素位移的动画，不要更改margin之类的属性，使用定位脱离文档流后改变位置会更好。")]),e._v(" "),t("p",[t("strong",[e._v("4.获取元素的偏移量属性")])]),e._v(" "),t("p",[e._v("例如获取一个元素的scrollTop、scrollLeft、scrollWidth、offsetTop、offsetLeft、offsetWidth、offsetHeight之类的属性，浏览器为了保证值的正确也会回流取得最新的值，所以如果你要多次操作，最好取完做个缓存。")]),e._v(" "),t("p",[t("strong",[e._v("5.页面初次渲染")])]),e._v(" "),t("p",[e._v("这样的回流无法避免")]),e._v(" "),t("p",[t("strong",[e._v("6.浏览器窗口尺寸改变")])]),e._v(" "),t("p",[e._v("resize事件发生也会引起回流。")]),e._v(" "),t("p",[e._v("这里就不列举引起重绘的行为了，记住，回流一定伴随着重绘，所以上面的行为都会重绘，除此之外，例如修改背景颜色，字体颜色之类不影响布局的行为都只引发重绘。")]),e._v(" "),t("p",[e._v("该文章参考以下两位大大的文章:")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.jianshu.com/p/e081f9aa03fb",target:"_blank",rel:"noopener noreferrer"}},[e._v("什么是重绘,什么是回流,有什么区别?"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/echolun/p/10105223.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("页面优化,谈谈重绘和回流"),t("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=v.exports}}]);