(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{522:function(t,s,e){"use strict";e.r(s);var a=e(6),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("正则表达式由于其看起来奇奇怪怪的形式，一度让我十分害怕，但害怕也没有用，这是必须掌握的技能，所谓消除恐惧的最好方式就是面对恐惧，那下面我就来简单说一下正则的基本使用吧，奥里给！")]),t._v(" "),e("blockquote",[e("p",[t._v("正则的声明")])]),t._v(" "),e("ul",[e("li",[t._v("正则字面量")])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" pattern "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token regex"}},[e("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[t._v("test")]),e("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[t._v("/")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这里的//斜杠与字符串的引号类似，用于分割正则式子")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])]),e("ul",[e("li",[t._v("使用RegExp构造")])]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" pattern "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RegExp")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("理论上以上两种方式都可以构造正则式，但在开发环境明确时，推荐使用字面量方式构造")]),t._v(" "),e("blockquote",[e("p",[t._v("正则修饰符")])]),t._v(" "),e("p",[t._v("除了表达式本身，还可以使用以下五个修饰符")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("符号名称")]),t._v(" "),e("th",[t._v("作用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("i   如：/test/i")]),t._v(" "),e("td",[t._v("对大小写不敏感，例子中表示不仅可以匹配test，还可以匹配TEST，Test等")])]),t._v(" "),e("tr",[e("td",[t._v("g")]),t._v(" "),e("td",[t._v("查找所有匹配项，在查找到第一个匹配时不会停止，会继续查找下一个匹配项")])]),t._v(" "),e("tr",[e("td",[t._v("m")]),t._v(" "),e("td",[t._v("允许多行匹配，对或许textarea元素的值很有用")])]),t._v(" "),e("tr",[e("td",[t._v("y")]),t._v(" "),e("td",[t._v("开启粘连匹配。"),e("code",[t._v("y")]),t._v("修饰符的作用与"),e("code",[t._v("g")]),t._v("修饰符类似，也是全局匹配，后一次匹配"),e("br"),t._v("都从上一次匹配成功的下一个位置开始。不同之处在于，"),e("code",[t._v("g")]),t._v("修饰符只要剩余位"),e("br"),t._v("置中存在匹配就可，而"),e("code",[t._v("y")]),t._v("修饰符确保匹配必须从剩余的第一个位置开始，这也"),e("br"),t._v("就是“粘连”的涵义。")])]),t._v(" "),e("tr",[e("td",[t._v("u")]),t._v(" "),e("td",[t._v("允许使用Unicoded点转义符")])])])]),t._v(" "),e("blockquote",[e("p",[t._v("术语与操作符")])])])}),[],!1,null,null,null);s.default=r.exports}}]);